#ifndef ITEM_H
#define ITEM_H

#include <deque>
#include <unordered_map>
#include <unordered_set>

#include "value.h"

using LinkId = std::string;
using ItemId = std::string;
using ItemIds = std::unordered_set<ItemId>;

// Link id used for events not produced or items not owned by a link handler.
const ItemId controlLinkId = "CONTROL";

class Item
{
public:
	struct SendOnTimerParams
	{
		// Shall unsolicited STATE_IND events be generated in case the owner link has not provided any for
		// a time span?
		bool active = false;

		// In case active = true:
		// Defines the time span starting from the last STATE_IND until an unsolicited STATE_IND is generated.
		Seconds interval = Seconds::zero();
	};

	struct SendOnChangeParams
	{
		// Shall STATE_IND events generated by the owner link only be forwarded in case the new item values
		// are different from the old ones?
		bool active = false;

		// In case active = true:
		// (current value) * (100 - (variation percentage)) <= new value <= (current value) * (100 + (variation percentage)) => ignore event
		Number relVariation = 0.0;

		// In case active = true:
		// New item values are suppressed in case they are inside the interval defined by this delta value.
		// (current value) - (variation value) <= new value <= (current value) + (variation value) => ignore event
		Number absVariation = 0.0;

		// In case active = true:
		// New item values are suppressed if they are greater than or equal to this one.
		Number minimum = std::numeric_limits<Number>::lowest();

		// In case active = true:
		// New item values are suppressed if they are lower than or equal to this one.
		Number maximum = std::numeric_limits<Number>::max();
	};

private:
	// Id of item for unique identification purpose.
	ItemId id;

	// Types of values which can be assigned to the item.
	ValueTypes valueTypes;

	// Unit of item values in case the item holds numbers.
	Unit unit;

	// Id of link who manages the item. That is, the link over which READ_REQ and WRITE_REQ for the item
	// are sent and on which STATE_IND for the item are received.
	LinkId ownerId;

	// Indicates whether the item can be queried by means of READ_REQ to the owner link.
	bool readable = true;

	// Indicates whether the item can be modified by means of WRITE_REQ to the owner link.
	bool writable = true;

	// Indicates whether the owner link automatically reacts with STATE_IND in case WRITE_REQ modifies the item.
	bool responsive = true;

	// Frequency in which READ_REQ events are generated automatically and passed to the owner link.
	Seconds pollingInterval = Seconds::zero();

	// Parameters for timer based STATE_IND generation.
	SendOnTimerParams sendOnTimerParams;

	// Parameters for change based STATE_IND suppression.
	SendOnChangeParams sendOnChangeParams;

	// Last seen and accepted value for the item.
	Value lastValue;

	struct HistoricValue
	{
		TimePoint timePoint;
		Number number;
		HistoricValue(TimePoint timePoint, Number number) : timePoint(timePoint), number(number) {};
	};

	// History of seen and accepted values ordered chronologically from newest to oldest.
	std::deque<HistoricValue> history;

	// Defines how long historic values are kept till they are discarded.
	Seconds historyPeriod = Seconds::zero();

	// Time of last published STATE_IND event for the item.
	TimePoint lastSendTime;

	// Time of last (internally) generated READ_REQ event for the item.
	TimePoint lastPollingTime;

public:	
	Item(ItemId id) : id(id) {}

	ItemId getId() const { return id; }

	void setOwnerId(LinkId _ownerId) { ownerId = _ownerId; }
	LinkId getOwnerId() const { return ownerId; }

	void setValueTypes(ValueTypes _valueTypes) { valueTypes = _valueTypes; }
	const ValueTypes& getValueTypes() const { return valueTypes; }
	bool hasValueType(ValueType valueType) const { return valueTypes.count(valueType); }

	void setUnit(Unit _unit) { unit = _unit; }
	Unit getUnit() const { return unit; }

	void setReadable(bool _readable) { readable = _readable; }
	bool isReadable() const { return readable; }

	void setWritable(bool _writable) { writable = _writable; }
	bool isWritable() const { return writable; }

	void setResponsive(bool _responsive) { responsive = _responsive; }
	bool isResponsive() const { return responsive; }

	void setLastValue(const Value& _value) { lastValue = _value; }
	const Value& getLastValue() const { return lastValue; }

	void setHistoryPeriod(Seconds _period) { historyPeriod = _period; }
	void addToHistory(TimePoint now, const Value& value);
	Value calcMinFromHistory(TimePoint start) const;
	Value calcMaxFromHistory(TimePoint start) const;

	void setSendOnTimerParams(SendOnTimerParams params) { sendOnTimerParams = params; }
	bool isSendOnTimerRequired(TimePoint now) const;

	void setLastSendTime(TimePoint _time) { lastSendTime = _time; }
	TimePoint getLastSendTime() const { return lastSendTime; }

	void setSendOnChangeParams(SendOnChangeParams params) { sendOnChangeParams = params; }
	bool isSendOnChangeEnabled() const { return sendOnChangeParams.active; }
	bool isSendOnChangeRequired(const Value& value) const;

	void setPollingInterval(Seconds _pollingInterval) { pollingInterval = _pollingInterval; }
	bool isPollingEnabled() const { return pollingInterval != Seconds::zero(); }
	bool isPollingRequired(TimePoint now) const;
	void initPolling(TimePoint now);
	void pollingDone(TimePoint now);

	void validateReadable(bool _readable) const;
	void validateWritable(bool _writable) const;
	void validateResponsive(bool _responsive) const;
	void validatePollingEnabled(bool _enabled) const;
	void validateHistory() const;
	void validateValueType(ValueType _valueType) const;
	void validateValueTypeNot(ValueType _valueType) const;
	void validateUnitType(UnitType _unitType) const;
	void validateOwnerId(LinkId _ownerId) const;
};

class Items: public std::unordered_map<ItemId, Item>
{
public:
	void add(Item item) { insert({item.getId(), item}); }
	bool exists(ItemId id) const { return find(id) != end(); }
	const Item& get(ItemId id) const { auto pos = find(id); assert(pos != end()); return pos->second; }
	Item& get(ItemId id) { auto pos = find(id); assert(pos != end()); return pos->second; }
	LinkId getOwnerId(ItemId id) const { return get(id).getOwnerId(); }

	Item& validate(ItemId itemId);
};

#endif
